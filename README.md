# stageflow
Библиотека для исполнения json пайплайнов

# Проблемы и риски

Этот список основан на быстром ревью текущего состояния репозитория.

- Нет зависимости: PyYAML используется в `stageflow/core/stage.py` и
  `stageflow/docs/schema.py`, но не объявлен в `pyproject.toml`.
- `Pipeline.from_dict` использует `{}` как дефолт для `nodes`; при итерации
  словаря берутся ключи, и `Node.from_dict` ломается.
- `Session.result` типизирован как `dict | None`, но при ошибках/таймаутах
  выставляется строка (`"failed"`, `"timeout"`), что ломает контракт.
- Риск циклического импорта: `stageflow/core/stage.py` импортирует
  `from stageflow.core import EventSpec, InputSpec` вместо локального импорта.
- `StageNode` содержит классовые изменяемые dict (`config/arguments/outputs`),
  что может дать shared-state ошибки; нужно избегать классовых mutables.
  shared-state ошибки.
- `BaseStage.allowed_events` / `allowed_inputs` — изменяемые списки на уровне
  класса, которые легко случайно разделить между наследниками.
- Валидация пайплайна не проверяет `node.next` для `StageNode`/`ParallelNode`,
  поэтому отсутствие ребер обнаружится только в рантайме.
- `ParallelNode.from_dict` без `@staticmethod`, стиль не согласован с остальными.
- `Session.wait_input` использует `asyncio.get_event_loop()` в async-контексте;
  предпочтительнее `get_running_loop()` в современном Python.
- Временные метки событий — naive UTC без timezone, что может быть неоднозначно.
- `py.typed` заявлен в package data, но файла нет в репозитории.
- `README.md` — дефолтный GitLab-шаблон; нет описания, установки, использования.
- В репозитории есть `__pycache__`/`.pyc`, которые не стоит коммитить.
- `test.py` импортирует `list_stages`, но публичный API экспортирует `get_stages`.


# Задачи

## P0 (ядро, корректность)

- ~~Добавить модель обработки ошибок на уровне пайплайна (fallback/on_error) как
  часть графа, а не только retries внутри стадии~~.
- ~~Порефакторить `Context`: изоляция/слияние при параллельных ветках, понятные
  правила конфликтов и копирования.~~
- ~~Переделать `wait_input`: поддержка нескольких ожиданий на один тип и
  рассылка входа всем ожидающим стадиям.~~

## P1 (стабильность и DX)

- ~~Софт-валидация событий: расширить `EventSpec`/`InputSpec` схемами (JSON
  Schema), добавить режимы `validate_events = off|warn|strict` на уровне
  `Session`/`Pipeline`. В `warn` — логировать `event_validation_failed` в
  history; в `strict` — останавливать/кидать ошибку. Проверять прежде всего
  входы, которые пришли в активные ожидания (`wait_input`).~~
- ~~Обновить `JsonLogic` после рефакторинга `Context`, чтобы условия могли
  работать с новой моделью данных (`payload`).~~
- ~~Валидация пайплайна по JSON Schema с версионированием (`api_version`), чтобы
  проверять формат и безопасно эволюционировать схему.~~
- ~~Добавить JSON-сериализацию состояния сессии (snapshot) для сохранения и
  восстановления: `Session.to_dict()`/`Session.from_dict()` с контрактом на
  `current_node`, `Context`, флаги и history; хранение делегировать пользователю.~~
- ~~Удалить `guards` из модели узлов, чтобы не усложнять (есть `condition`).~~
- ~~Порефакторить `parallel`: запускать полноценные ветки (подграфы), определить
  семантику отмены остальных веток и сбор результатов.~~
- С~~делать удобный тестер пайплайнов: описывать кейсы входов и прогонять их по
  пайплайну (ограничение на шаги/события, проверка ожидаемого результата).~~

## P2 (расширения)

- Добавить встроенные базовые стадии для ожидания и таймеров (`WaitStage`,
  `SleepStage`) как стандартные stage-узлы.
- Расширить типы нод: ~~подпайплайны как “суперноды” (вложенный пайплайн с
  входами/терминалами)~~, foreach/map.
- Добавить трассировку/логирование с корреляцией (trace_id, span_id,
  parent_span_id) для анализа выполнения пайплайнов.
- ~~Удалить LLM-провайдеры из ядра (вынести в отдельный пакет/плагин), чтобы
  не тянуть зависимости и лишнюю логику в базовой библиотеке.~~

# Глоссарий

- Пайплайн: граф выполнения, описанный JSON-конфигом.
- Нода (узел): элемент графа (stage/condition/parallel/terminal и т.п.).
- Stage (стадия): исполняемая единица логики (код), которую вызывает StageNode.
- StageNode: нода, которая запускает конкретную Stage.
- ConditionNode: нода, которая выбирает следующую ветку по условию.
- ParallelNode: нода, которая запускает несколько веток параллельно.
- TerminalNode: нода завершения, возвращает результат и артефакты.
- Контекст (Context): общие данные пайплайна (`payload`).
- Сессия (Session): запуск пайплайна с конкретным контекстом и историей событий.
- Событие (Event): структурированная запись о действии в сессии.
- Вход (Input): внешнее событие/данные, которые приходят в Session.
- Аргументы (arguments): маппинг путей контекста в входы стадии.
- Выходы (outputs): маппинг результатов стадии обратно в контекст.
- Артефакты: выбранные пути контекста, которые возвращаются в результате.

# Тестовый пайплайн (опорный)

Минимальный JSON, который использует все текущие возможности движка:
stage → condition → parallel → terminal, с аргументами, выходами и артефактами.

```json
{
  "api_version": "1.0",
  "entry": "start",
  "metadata": { "name": "demo_full_flow" },
  "nodes": [
    {
      "id": "start",
      "type": "stage",
      "stage": "InitStage",
      "config": { "mode": "demo" },
      "arguments": {
        "user_id": "user_id",
        "text": "text"
      },
      "outputs": {
        "score": "score",
        "need_parallel": "need_parallel"
      },
      "next": "decide"
    },
    {
      "id": "decide",
      "type": "condition",
      "conditions": [
        {
          "if": { "==": [ { "var": "need_parallel" }, true ] },
          "then": "fanout"
        }
      ],
      "else": "finish"
    },
    {
      "id": "fanout",
      "type": "parallel",
      "policy": "all",
      "children": ["branch_a", "branch_b"],
      "next": "finish"
    },
    {
      "id": "branch_a",
      "type": "stage",
      "stage": "WorkerAStage",
      "arguments": { "score": "score" },
      "outputs": { "a_result": "a_result" }
    },
    {
      "id": "branch_b",
      "type": "stage",
      "stage": "WorkerBStage",
      "arguments": { "score": "score" },
      "outputs": { "b_result": "b_result" }
    },
    {
      "id": "finish",
      "type": "terminal",
      "result": { "status": "ok" },
      "artifacts": ["score", "a_result", "b_result"]
    }
  ]
}
```
